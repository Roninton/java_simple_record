本文档包含7个经典设计模式的Java实现示例，涵盖了创建型、结构型和行为型三大类设计模式。每个模式都是为了解决特定的软件设计问题而诞生的。

## 设计模式分类

### 创建型模式 (Creational Patterns)
负责对象的创建过程，使得对象的创建更加灵活和可控。

### 结构型模式 (Structural Patterns)  
关注类和对象的组合，形成更大的结构。

### 行为型模式 (Behavioral Patterns)
关注对象之间的通信和职责分配。

---

## 详细模式介绍

### 1. 工厂模式 (Factory Pattern)
**文件**: `FactoryPatternExample.java`

#### 解决的实际痛点：
- **对象创建复杂性**: 当创建对象的过程很复杂时，客户端不应该关心具体的创建细节
- **代码耦合度高**: 直接使用new关键字创建对象会导致代码紧耦合
- **扩展困难**: 添加新的产品类型时需要修改现有代码

#### 应用场景：
- 数据库连接工厂
- 日志记录器工厂
- UI组件工厂
- 第三方API客户端工厂

#### 优点：
✅ 隐藏对象创建的复杂性
✅ 降低代码耦合度
✅ 易于扩展新的产品类型
✅ 符合开闭原则

#### 缺点：
❌ 增加了类的数量
❌ 可能导致类层次过于复杂
❌ 简单对象创建可能显得过度设计

---

### 2. 观察者模式 (Observer Pattern)
**文件**: `ObserverPatternExample.java`

#### 解决的实际痛点：
- **一对多依赖关系管理**: 当一个对象状态改变需要通知多个其他对象时
- **松耦合通信**: 发布者和订阅者之间需要解耦
- **实时更新需求**: 需要实时响应状态变化的场景

#### 应用场景：
- GUI事件处理系统
- MVC架构中的模型-视图通信
- 消息发布订阅系统
- 股票价格监控系统
- 社交媒体通知系统

#### 优点：
✅ 定义了稳定的更新触发机制
✅ 支持广播通信
✅ 符合开闭原则
✅ 动态建立和删除观察者

#### 缺点：
❌ 如果观察者列表很长，通知可能耗时
❌ 意外的更新可能导致连锁反应
❌ 内存泄漏风险（观察者未正确注销）
❌ 调试困难（复杂的观察者网络）

---

### 3. 单例模式 (Singleton Pattern)
**文件**: `SingletonPatternExample.java`

#### 解决的实际痛点：
- **资源竞争**: 确保整个应用程序只有一个实例访问共享资源
- **内存浪费**: 避免创建多个相同功能的实例
- **全局访问点**: 提供全局唯一的访问点

#### 应用场景：
- 数据库连接池
- 日志记录器
- 配置管理器
- 缓存管理器
- 线程池管理

#### 优点：
✅ 节省内存空间
✅ 全局唯一访问点
✅ 延迟初始化能力
✅ 线程安全选项

#### 缺点：
❌ 违反单一职责原则
❌ 难以进行单元测试
❌ 隐藏了类之间的依赖关系
❌ 可能成为性能瓶颈
❌ 在分布式环境中难以保证单例

---

### 4. 装饰器模式 (Decorator Pattern)
**文件**: `DecoratorPatternExample.java`

#### 解决的实际痛点：
- **继承爆炸问题**: 避免为每种组合创建大量子类
- **动态功能扩展**: 运行时动态地给对象添加功能
- **功能组合灵活性**: 支持多种功能的任意组合

#### 应计场景：
- Java I/O流系统
- 图形界面组件增强
- 网络请求拦截器
- 数据处理管道
- 权限验证装饰器

#### 优点：
✅ 比继承更灵活
✅ 符合开闭原则
✅ 可以用多个装饰器包装一个对象
✅ 装饰器可以在运行时添加或删除

#### 缺点：
❌ 产生很多小对象
❌ 难以理解多层次的装饰
❌ 调试困难
❌ 可能影响性能（多层包装）

---

### 5. 策略模式 (Strategy Pattern)
**文件**: `StrategyPatternExample.java`

#### 解决的实际痛点：
- **算法切换需求**: 需要在运行时切换不同的算法实现
- **避免条件语句**: 减少大量的if-else或switch语句
- **算法复用**: 不同的上下文可以复用相同的算法

#### 应用场景：
- 支付方式选择
- 排序算法切换
- 路径规划算法
- 压缩算法选择
- 验证规则引擎

#### 优点：
✅ 算法可以自由切换
✅ 避免使用多重条件判断
✅ 扩展性好，符合开闭原则
✅ 算法可以复用

#### 缺点：
❌ 客户端必须知道所有的策略类
❌ 增加了对象数量
❌ 所有策略类都需要对外暴露

---

### 6. 建造者模式 (Builder Pattern)
**文件**: `BuilderPatternExample.java`

#### 解决的实际痛点：
- **复杂对象构建**: 构造函数参数过多，难以理解和维护
- **对象一致性**: 确保复杂对象在构建过程中保持一致状态
- **步骤控制**: 需要精确控制对象构建的各个步骤

#### 应用场景：
- 复杂配置对象创建
- SQL查询构建器
- HTML/XML文档生成
- 用户注册流程
- API请求构建

#### 优点：
✅ 将复杂对象的构建与其表示分离
✅ 支持链式调用，代码更易读
✅ 可以控制构建过程的步骤
✅ 同一构建过程可以创建不同的表示

#### 缺别：
❌ 代码复杂度增加
❌ 需要额外编写建造者类
❌ 产品内部发生变化时可能需要调整建造者

---

### 7. 适配器模式 (Adapter Pattern)
**文件**: `AdapterPatternExample.java`

#### 解决的实际痛点：
- **接口不兼容**: 现有类的接口不符合客户端期望
- **遗留系统集成**: 需要集成旧系统但接口不匹配
- **第三方库适配**: 第三方库接口与现有系统不兼容

#### 应用场景：
- 数据库驱动适配
- 不同支付网关统一接口
- 不同日志框架适配
- 硬件设备驱动程序
- API版本兼容性处理

#### 优点：
✅ 可以让任何两个没有关联的类一起运行
✅ 提高了类的复用性
✅ 增加了类的透明度
✅ 灵活性好

#### 缺点：
❌ 过多地使用适配器会让系统非常零乱
❌ 增加代码复杂度
❌ 难以调试（多层适配）

---

## 设计模式选择指南

### 何时使用创建型模式：
- 对象创建过程复杂时 → 工厂模式
- 只需要一个实例时 → 单例模式  
- 构建复杂对象时 → 建造者模式

### 何时使用结构型模式：
- 需要扩展对象功能时 → 装饰器模式
- 接口不兼容需要转换时 → 适配器模式

### 何时使用行为型模式：
- 需要定义对象间通信时 → 观察者模式
- 需要算法切换时 → 策略模式

## 最佳实践建议

1. **不要过度设计**: 简单场景不需要复杂模式
2. **优先组合而非继承**: 多用委托少用继承
3. **考虑测试友好性**: 模式不应增加测试难度
4. **关注团队接受度**: 选择团队熟悉的模式
5. **渐进式应用**: 从简单模式开始逐步引入

## 性能考量

- 单例模式需要注意线程安全和延迟加载的平衡
- 装饰器模式的多层包装可能影响性能
- 观察者模式的通知机制可能成为瓶颈
- 工厂模式的对象创建开销需要评估

## 总结

设计模式是解决软件设计问题的经验总结，但不是银弹。合理使用设计模式可以提高代码质量，但滥用反而会增加复杂性。关键是要理解每个模式适用的场景和局限性，在实际开发中做出明智的选择。